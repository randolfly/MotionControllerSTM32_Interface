@page "/DataLog"
@using System.Windows
@using MotionInterface.Lib.Model
@using MotionInterface.Lib.Service
@using MotionInterface.Lib.Util
@using MotionInterface.Util

@inject IPopupService PopupService
@inject CommandCommunicationService CommandCommunicationService
@inject DataLogService DataLogService

<MContainer Fluid Class="fill-height">
    <MRow Style="min-height:200px">
        <MCol Cols="12" Md="6">
            <MCard Class="mx-auto">
                <MList Dense>
                    <MListItemGroup
                        @bind-Values="RecordSymbolName"
                        Multiple
                        Color="indigo">
                        @foreach (var symbol in CommandCommunicationService.AvailableSymbolName)
                        {
                        <MListItem @key="symbol" Value="symbol">
                            <MListItemContent>
                                <MListItemTitle>@symbol</MListItemTitle>
                            </MListItemContent>
                        </MListItem>
                        }
                    </MListItemGroup>
                </MList>
            </MCard>
        </MCol>
        <MCol Cols="12" Md="6">
            <MCard Class="mx-auto">
                <MList Dense>
                    <MListItemGroup
                        @bind-Values="GraphSymbolName"
                        Multiple
                        Color="indigo">
                        @foreach (var symbol in RecordSymbolName)
                        {
                        <MListItem @key="symbol" Value="symbol">
                            <MListItemContent>
                                <MListItemTitle>@symbol</MListItemTitle>
                            </MListItemContent>
                        </MListItem>
                        }
                    </MListItemGroup>
                </MList>
            </MCard>
        </MCol>
    </MRow>
    <MRow NoGutters Style="margin-top: 10px;">
        <MCol Cols="3" Style="display: flex;justify-content:space-around">
            <MButton Color="primary" OnClick="GetAvailableRecordDataNames">
                GetAvailable
            </MButton>
        </MCol>
        <MCol Cols="3" Style="display: flex;justify-content:space-around">
            <MButton Color="primary"  OnClick="SetRecordDataNames">
                SetRecord
            </MButton>
        </MCol>
        <MCol Cols="3" Style="display: flex;justify-content:space-around">
            <MButton Color="primary"  OnClick="StartRecordData">
                StartRecord
            </MButton>
        </MCol>
        <MCol Cols="3" Style="display: flex;justify-content:space-around">
            <MButton Color="primary"  OnClick="StopRecordData">
                StopRecord
            </MButton>
        </MCol>
    </MRow>
</MContainer>

@code {
    
    private Dictionary<string, FigureViewWindow> FigureViewWindowDictionary { get; set; } = new();
    
    private List<StringNumber> RecordSymbolName
    {
        get => CommandCommunicationService.RecordSymbolName.ToStringNumber();
        set => OnRecordSymbolChanged(value);
    }
    
    private void OnRecordSymbolChanged(List<StringNumber> symbolInfoPaths)
    {
        CommandCommunicationService.RecordSymbolName = symbolInfoPaths
            .Select(sn=>sn.ToString()).ToList()!;
    }
    
    private List<StringNumber> GraphSymbolName
    {
        get => CommandCommunicationService.GraphSymbolName.ToStringNumber();
        set => OnGraphSymbolChanged(value);
    }

    protected override void OnInitialized()
    {
        base.OnInitialized();
        DataLogService.OnParseFrameDataAction = UpdateGraphViewData;
    }

    private void OnGraphSymbolChanged(List<StringNumber> symbolInfoPaths)
    {
        CommandCommunicationService.GraphSymbolName = symbolInfoPaths
            .Select(sn=>sn.ToString()).ToList()!;
    }

    private void SetRecordDataNames()
    {
        if (CommandCommunicationService.IsPortOpen)
        {
            CommandCommunicationService.SetRecordDataNames();
        }
        else
        {
            PopupService.EnqueueSnackbarAsync("Please check if serial port is opened");
        }
        StateHasChanged();
    }

    private void GetAvailableRecordDataNames()
    {
        if (CommandCommunicationService.IsPortOpen)
        {
            CommandCommunicationService.GetAvailableRecordDataNames();
        }
        else
        {
            PopupService.EnqueueSnackbarAsync("Please check if serial port is opened"); 
        }
        StateHasChanged();
    }

    private void StartRecordData()
    {
        if (!CommandCommunicationService.IsPortOpen)
        {
            PopupService.EnqueueSnackbarAsync("Please check if serial port is opened"); 
            return;
        }
        // check echo record names right
        var recordName = CommandCommunicationService.RecordSymbolName;
        var echoName = CommandCommunicationService.EchoRecordSymbolName;
        var checkPass = false;
        if (recordName.Count == echoName.Count)
        {
            for (var i = recordName.Count - 1; i >= 0; i--)
            {
                if (echoName[i] == recordName[i]) continue;
                checkPass = false;
                break;
            }
        }
        if (checkPass)
        {
            if (recordName.Count <= 0) return;
            ClearRecordData();
            CommandCommunicationService.StartRecordData();
            DataLogService.StartDataLog();
            ShowGraphView(CommandCommunicationService.GraphSymbolName);
        }
        else
        {
            PopupService.EnqueueSnackbarAsync("Record and Echo Names not same");   
        }
        StateHasChanged();
    }

    private void ClearRecordData()
    {
        RecordSymbolName.Clear();
        FigureViewWindowDictionary.Values.ForEach(w => w.Close());
        FigureViewWindowDictionary.Clear();
    }

    private void StopRecordData()
    {
        if (!CommandCommunicationService.IsPortOpen)
        {
            PopupService.EnqueueSnackbarAsync("Please check if serial port is opened"); 
            return;
        }
        CommandCommunicationService.StopRecordData();
        DataLogService.StopDataLog();
        
        foreach (var figureViewWindow in FigureViewWindowDictionary.Values)
        {
            figureViewWindow.ScaleRangeToMax();
        }
        StateHasChanged();
    }

    private void UpdateGraphViewData(int startId)
    {
        var recordSymbolData = DataLogService.RecordData;
        var endId = recordSymbolData.Count;
        var recordSymbolList = CommandCommunicationService.RecordSymbolName;
        var graphSymbolList = CommandCommunicationService.GraphSymbolName;
        
        var graphSymbolIndex = recordSymbolList.FindSubStringListIndex(graphSymbolList);
        for (var graphSymbolId = 0;  graphSymbolId < graphSymbolList.Count; graphSymbolId++)
        {
            for (var numId = startId; numId < endId; numId++)
            {
                FigureViewWindowDictionary[graphSymbolList[graphSymbolId]]
                    .UpdateData(recordSymbolData[numId][graphSymbolId]);
            }
        }
    }

    private void ShowGraphView(List<string> graphSymbolInfos)
    {
        foreach (var figureViewWindow in FigureViewWindowDictionary.Values)
        {
            figureViewWindow.CloseWindow();
        }

        FigureViewWindowDictionary.Clear();
        for (var i = 0; i < graphSymbolInfos.Count; i++)
        {
            // todo: update all figure log period functions
            var symbolInfo = graphSymbolInfos[i];
            FigureViewWindow.LogPeriod = 1;
            var (left, top) = GetGraphViewWindowPos(i, graphSymbolInfos.Count);
            var figureViewWindow = new FigureViewWindow { Title = symbolInfo, Left = left, Top = top };
            FigureViewWindowDictionary.Add(symbolInfo, figureViewWindow);
            figureViewWindow.Show();
        }
    }
    
    private static (double x, double y) GetGraphViewWindowPos(int id, int windowNum, int windowWidth = 600,
        int windowHeight = 300)
    {
        const int windowRowSize = 3;
        var desktopWorkingArea = SystemParameters.WorkArea;
        var left = desktopWorkingArea.Right - ((int)(id / windowRowSize) + 1) * windowWidth;
        var top = desktopWorkingArea.Bottom - (id % windowRowSize + 1) * windowHeight;
        return (left, top);
    }

}